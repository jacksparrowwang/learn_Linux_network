<!DOCTYPE html>
<html>
    <head>
        <title> 王成刚项目详细介绍 </title>
        <!-- 设置字体编码 -->
        <meta http-equiv="Content-Type" content="./index.html; charset=utf-8">
		<style>
<!-- 首行标题 -->
header {
    color:blue;
    text-align:center;
    padding:4px;	 
}
		</style>
    </head>
    <!-- 背景图片 -->
    <body background="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2820292421,3434353566&fm=27&gp=0.jpg"style=" background-repeat:no-repeat;background-size:100% 100%;
background-attachment: fixed;">
	<!-- <canvas id="myCanvas" width="1024" height="25" style="border:1px solid #c3c3c3;"></canvas> -->

<!-- <script type="text/javascript"> -->

<!-- var c=document.getElementById("myCanvas"); -->
<!-- var cxt=c.getContext("2d"); -->
<!-- var grd=cxt.createLinearGradient(0,0,1024,25); -->
<!-- grd.addColorStop(0,"#FF0000"); -->
<!-- grd.addColorStop(1,"#00FF00"); -->
<!-- cxt.fillStyle=grd; -->
<!-- cxt.fillRect(0,0,1024,25); -->

<!-- </script> -->

<header>
<h1>欢迎来到王成刚项目介绍网页</h1>
</header>

<h3>&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;项目：网络对战五子棋 </h3>   
&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;<strong>代码：<a href="https://github.com/jacksparrowwang/learn_git/tree/master/netgobang" target="_blank">网络对战五子棋</a></strong>
<div class="cities" style="display: block; margin: 0 auto; width: 80%; line-height:25px";>
<pre style="font-family:KaiTi_GB2312;font-size:16px;">
项目实现想法：
    感觉实现一个自己的游戏是一件很有趣，很刺激的事情，在编写过程中的确是很有成就感
    自己就打算模拟实现一个五子棋，尽可能的实现五子棋游戏中的功能，这样我就可以
    不仅对自己所学知识有所应用，更学习了许多新的知识，在动手实践的过程中去体会课本中的知识
    体会自定义应用层协议锻炼自己的编程能力，熟悉自己在网络方面的知识。
</pre>
<pre style="font-family:KaiTi_GB2312;font-size:16px;">
项目功能：
    实现了人机对战，机器设置是以人的下棋为基准进行判断生成自己要下的位置，输入判错，胜负判断，平局判断
    下错悔棋处理功能。
    实现联机对战，通过服务器实现客户端与客户端之间的对战，能够同时满足多人的对战
</pre>
<pre style="font-family:KaiTi_GB2312;font-size:16px;">
实现流程：
    服务器：
        1) 自己制定应用层服务器与客户端之间的协议，采用传送坐标结构体。
        2) 通过命令行参数，来进行服务器IP，port 的传入，socket拿到文件描述符，绑定端口号，用TCP协议建立监听
        3) 循环的用accept函数处理建立连接，创建线程并分离出去进行处理建立连接的客户端，每次等待两个建
            立连接建，分别发送一个标识给连接的客户端，用来确定先手下棋者，在进行创建两个线程进行分别处理。
        4) 在建立连接的过程中加上数据库，进行连接记录。
        5) 我定义先建立连接的人为先下棋者，所以先下棋者为生产者，后建立者为消费者。
            当先下棋者没有在文件描述符中写数据时候，后下棋者进行阻塞等待。
            当先下棋者在文件描述符中写数据后，就进入读状态，后下棋者就从读取数据，进入写状态
            这时候，生产者与消费者对象就转变。
    客户端：
        1) 制定应用层服务器与客户端之间的通信协议。
        2) 通过命令行参数传入服务器IP，port.
        3) 通过游戏菜单来让用户进行游戏模式选择
        4) 人机离线模式
            人落子，判断是否落子合法性，
            判断是否胜利
            机器根据人落子进行复杂的判断来生成机器要下的位置
            判断是否胜利
            循环对战
        5) 连接对战模式
            调用connect函数进行三次握手请求建立连接。
            阻塞等待服务器发送消息，来确定本次连接是先下棋者还是后下棋者
            生产者消费者模型来进行数据的发送与收取
</pre>
         
<pre style="font-family:KaiTi_GB2312;font-size:16px;">
改进想法:
    添加图形化界面，因为是用c语言实现的，所以实现图形化比较困难，所以我可以把项目写成一个网页版的
    用html网页来作为图形话处理，添加注册登陆，把注册信息添加到数据库。
</pre>
        </div>

    <h3>&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;项目：哈夫曼压缩 </h3>
    &#8195;&#8195;&#8195;&#8195;&#8195;&#8195;&#8195;<strong>代码：<a href="https://github.com/jacksparrowwang/cg19.github.com/tree/master/item/file_compress_item" target="_blank">哈夫曼压缩</a></strong>
<div class="cities"style="display: block; margin: 0 auto; width: 80%">
<pre style="font-family:KaiTi_GB2312;font-size:16px;">
    项目实现想法：
        在学习过程中，看到zip压缩中就有huffman数据数据结构，当时就想自己能否实现，也能够学以致用，
        增加自己的实践能力。
</pre>
<pre style="font-family:KaiTi_GB2312;font-size:16px;">
    实现流程：
    压缩：
        1) 首先我们建立模板哈夫曼树，哈夫曼树又名最优二叉树，用带权的节点建立二叉树，所有节点都位于叶子节点
            以权值采用优先级队列，建立小堆，构造出模板huffman树。
        2) 打开要压缩的文件，用哈希表来进行统计文件中每个字符出现的次数，以此作为构建Huffman树的权值
            调用huffman模板构造出以字符个数权值的huffman树
        3) 通过构建好的huffman树，从根开始，我们规定一个节点的左为0，右为1，那么就会根到每个叶节点上的路径
            是唯一的路径，所以我们用路径来生成编码，来代替原来字符的编码
        4) 基本工作已经完成，开始进行压缩，先把用来统计字符出现次数的哈希表写入文件中，这是为了解压和压缩
            分离开来也能够正常使用。
        5) 利用生成编码后，重新创建出一个压缩的文件，来进行新编码的保存，采用位运算的方式，把路径的上的编码
            压入字符中，满一个字符就写道文件中
    解压：
        6) 先将压缩文件中的最开始的哈希表读取出来，再进行huffman树的构建
        7) 将压缩文件中的每个字符读出来，进行位运算，拿出的二进制就可以在huffman树中找到唯一的叶子节点
            将叶子节点的字符写入解压文件中
        8) 处理解压文件中最后一个字符中只有几个bit位有效问题，因为构建的是带权最优二叉树，所以根节点的权值
            就是所有字符的个数，所以每次解压出来一个字符，就减一，完成解压
</pre>
<pre style="font-family:KaiTi_GB2312;font-size:16px;">
    改进想法：
        实现文件夹的压缩，实现文件夹的压缩，我们可以打开文件夹，抽取其中的内容，如果文件夹中还有
        文件夹，那么就递归的去打开文件夹抽取其中的内容进行压缩。

</pre>
</div>
        </body>
    </html>

